#include "oneflow/core/framework/op_generated.h"

namespace oneflow {

/* static */ Maybe<void> OfrecordRawDecoderOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in_tensor = ctx->InputTensorDesc("in", 0);
      user_op::TensorDesc* out_tensor = ctx->OutputTensorDesc("out", 0);
      CHECK_OR_RETURN(in_tensor.shape().NumAxes() == 1 && in_tensor.shape().At(0) >= 1);
      Shape conf_shape = ctx->Attr<Shape>("shape");
      DimVector dim_vec(1 + conf_shape.NumAxes());
      dim_vec[0] = in_tensor.shape().At(0);
      for (int i = 1; i < dim_vec.size(); ++i) { dim_vec[i] = conf_shape.At(i - 1); }
      *out_tensor->mut_shape() = Shape(dim_vec);
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> OfrecordRawDecoderOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> OfrecordRawDecoderOp::GetSbp(user_op::SbpContext *ctx) {
      ctx->NewBuilder()
          .Split(user_op::OpArg("in", 0), 0)
          .Split(user_op::OpArg("out", 0), 0)
          .Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> OfrecordRawDecoderOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
      user_op::InputArgModifier* in_modifier = GetInputArgModifierFn("in", 0);
      CHECK_NOTNULL_OR_RETURN(in_modifier);
      in_modifier->set_requires_grad(false);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> OfrecordRawDecoderOp::InferDataType(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in_tensor = ctx->InputTensorDesc("in", 0);
      user_op::TensorDesc* out_tensor = ctx->OutputTensorDesc("out", 0);
      CHECK_OR_RETURN(in_tensor.data_type() == DataType::kOFRecord);
      *out_tensor->mut_data_type() = ctx->Attr<DataType>("data_type");
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> OfrecordBytesDecoderOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in = ctx->InputTensorDesc("in", 0);
      user_op::TensorDesc* out = ctx->OutputTensorDesc("out", 0);
      *out->mut_is_dynamic() = in.is_dynamic();
      *out->mut_shape() = in.shape();
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> OfrecordBytesDecoderOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> OfrecordBytesDecoderOp::GetSbp(user_op::SbpContext *ctx) {
return user_op::GetSbpFnUtil::S(ctx);
}

/* static */ Maybe<void> OfrecordBytesDecoderOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
      user_op::InputArgModifier* in_modifier = GetInputArgModifierFn("in", 0);
      CHECK_NOTNULL_OR_RETURN(in_modifier);
      in_modifier->set_requires_grad(false);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> OfrecordBytesDecoderOp::InferDataType(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in = ctx->InputTensorDesc("in", 0);
      user_op::TensorDesc* out = ctx->OutputTensorDesc("out", 0);
      CHECK_OR_RETURN(in.data_type() == DataType::kOFRecord);
      *out->mut_data_type() = DataType::kTensorBuffer;
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> OfrecordImageDecoderOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in_tensor = ctx->InputTensorDesc("in", 0);
      user_op::TensorDesc* out_tensor = ctx->OutputTensorDesc("out", 0);
      CHECK_OR_RETURN(in_tensor.shape().NumAxes() == 1 && in_tensor.shape().At(0) >= 1);
      *out_tensor->mut_shape() = in_tensor.shape();
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> OfrecordImageDecoderOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> OfrecordImageDecoderOp::GetSbp(user_op::SbpContext *ctx) {
      ctx->NewBuilder()
          .Split(user_op::OpArg("in", 0), 0)
          .Split(user_op::OpArg("out", 0), 0)
          .Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> OfrecordImageDecoderOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
      user_op::InputArgModifier* in_modifier = GetInputArgModifierFn("in", 0);
      CHECK_NOTNULL_OR_RETURN(in_modifier);
      in_modifier->set_requires_grad(false);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> OfrecordImageDecoderOp::InferDataType(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in_tensor = ctx->InputTensorDesc("in", 0);
      user_op::TensorDesc* out_tensor = ctx->OutputTensorDesc("out", 0);
      CHECK_OR_RETURN(in_tensor.data_type() == DataType::kOFRecord);
      *out_tensor->mut_data_type() = DataType::kTensorBuffer;
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> OfrecordImageDecoderRandomCropOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in_tensor = ctx->InputTensorDesc("in", 0);
      user_op::TensorDesc* out_tensor = ctx->OutputTensorDesc("out", 0);
      CHECK_OR_RETURN(in_tensor.shape().NumAxes() == 1 && in_tensor.shape().At(0) >= 1);
      *out_tensor->mut_shape() = in_tensor.shape();
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> OfrecordImageDecoderRandomCropOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> OfrecordImageDecoderRandomCropOp::GetSbp(user_op::SbpContext *ctx) {
      ctx->NewBuilder()
          .Split(user_op::OpArg("in", 0), 0)
          .Split(user_op::OpArg("out", 0), 0)
          .Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> OfrecordImageDecoderRandomCropOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
      user_op::InputArgModifier* in_modifier = GetInputArgModifierFn("in", 0);
      CHECK_NOTNULL_OR_RETURN(in_modifier);
      in_modifier->set_requires_grad(false);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> OfrecordImageDecoderRandomCropOp::InferDataType(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in_tensor = ctx->InputTensorDesc("in", 0);
      user_op::TensorDesc* out_tensor = ctx->OutputTensorDesc("out", 0);
      CHECK_OR_RETURN(in_tensor.data_type() == DataType::kOFRecord);
      *out_tensor->mut_data_type() = DataType::kTensorBuffer;
      return Maybe<void>::Ok();
    }

